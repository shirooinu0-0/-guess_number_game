import gradio as gr
import random

class TripleModeGame:
    def __init__(self):
        self.colors = ["ğŸ”´ ç´…è‰²", "ğŸŸ¡ é»ƒè‰²", "ğŸ”µ è—è‰²", "ğŸŸ¢ ç¶ è‰²", "ğŸŸ£ ç´«è‰²"]
        self.max_stamina = 10
        self.reset("ç¶“å…¸ç”Ÿå­˜æˆ°", 10)

    def reset(self, mode, max_stamina):
        self.mode = mode
        self.max_stamina = int(max_stamina)
        self.stamina = self.max_stamina
        self.target = random.randint(1, 100)
        self.low, self.high = 1, 100
        self.property_guessed = False 
        self.target_property = "å¶æ•¸" if self.target % 2 == 0 else "å¥‡æ•¸"

        if mode == "è‰²å½©åµæŸ¥æˆ°":
            # è‰²å½©æ¨¡å¼ä¸‹ç¯„åœè¼ƒçª„ï¼Œå¢åŠ ç­–ç•¥æ€§
            start = max(1, self.target - random.randint(5, 15))
            self.num_range = list(range(start, min(101, start + 30)))
            self.color_map = {n: random.choice(self.colors) for n in self.num_range}
            self.target_color = self.color_map[self.target]
        return self.get_ui_status()

    def get_ui_status(self):
        heart_icons = "â¤ï¸" * max(0, self.stamina)
        status = f"ã€ç•¶å‰ç‹€æ…‹ã€‘\nğŸ’– é«”åŠ›ï¼š{heart_icons} ({self.stamina}/{self.max_stamina})\n"
        status += f"ğŸ” æ•¸å­—ç¯„åœï¼š{self.low} â†”ï¸ {self.high}\n"
        status += "â”€" * 20 + "\n"

        if self.mode == "ç¶“å…¸ç”Ÿå­˜æˆ°":
            status += "ğŸ“ æ¨¡å¼ï¼šç¶“å…¸ | ç›®æ¨™ï¼šçŒœä¸­ 1-100 é–“çš„æ•¸å­—ã€‚"
        elif self.mode == "å±¬æ€§è§£ç¢¼æˆ°":
            status += f"ğŸ“ æ¨¡å¼ï¼šå±¬æ€§ | ç‹€æ…‹ï¼š{'âœ… å·²è§£é–å±¬æ€§ - ' + self.target_property if self.property_guessed else 'ğŸ”’ å±¬æ€§æœªçŸ¥ï¼Œè«‹å…ˆé æ¸¬'}"
        elif self.mode == "è‰²å½©åµæŸ¥æˆ°":
            status += f"âš ï¸ æ¨¡å¼ï¼šè‰²å½©åµæŸ¥æˆ°\nğŸ›‘ è­¦å‘Šï¼šæœ¬æ¨¡å¼é›£åº¦æ¥µé«˜ï¼Œã€ç­”éŒ¯ä¸€æ¬¡æ‰£ 2 é¡†å¿ƒã€‘ï¼\n"
            status += f"ğŸ¯ ç›®æ¨™é¡è‰²æ˜¯ï¼šã€ {self.target_color} ã€‘\n"
            matrix_str = "".join([f"{n:3d}:{self.color_map[n]} " + ("\n" if (i+1)%5==0 else "") for i, n in enumerate(self.num_range)])
            status += "--- å€åŸŸè‰²å½©çŸ©é™£ ---\n" + matrix_str
        return status

game = TripleModeGame()

def play_engine(guess_num, mode, max_stamina, odd_even_guess):
    if game.mode != mode or game.max_stamina != int(max_stamina):
        game.reset(mode, max_stamina)
        return "ğŸ”„ åµæ¸¬åˆ°æ¨¡å¼è®Šæ›´ï¼ŒéŠæˆ²å·²é‡ç½®ã€‚", game.get_ui_status()

    # --- ç¬¬ä¸€éšæ®µï¼šå±¬æ€§é æ¸¬ ---
    if mode == "å±¬æ€§è§£ç¢¼æˆ°" and not game.property_guessed:
        if not odd_even_guess:
            return "âš ï¸ è«‹å…ˆé¸æ“‡å³å´çš„ [å¥‡æ•¸] æˆ– [å¶æ•¸]ï¼", game.get_ui_status()
        
        game.property_guessed = True
        if odd_even_guess == game.target_property:
            return f"âœ¨ é æ¸¬æˆåŠŸï¼ç­”æ¡ˆç¢ºå¯¦æ˜¯ {game.target_property}ã€‚è«‹é–‹å§‹çŒœæ•¸å­—ã€‚", game.get_ui_status()
        else:
            game.stamina -= 2
            if game.stamina <= 0:
                final_msg = f"âŒ é æ¸¬éŒ¯èª¤ä¸”é«”åŠ›æ­¸é›¶ï¼ç­”æ¡ˆæ˜¯ {game.target}ã€‚éŠæˆ²çµæŸã€‚"
                game.reset(mode, max_stamina)
                return final_msg, game.get_ui_status()
            return f"ğŸ’” é æ¸¬éŒ¯èª¤ï¼æ‰£é™¤ 2 é¡†å¿ƒã€‚æƒ…å ±é¡¯ç¤ºç­”æ¡ˆå…¶å¯¦æ˜¯ {game.target_property}ã€‚", game.get_ui_status()

    # --- ç¬¬äºŒéšæ®µï¼šçŒœæ•¸å­— ---
    if guess_num is None:
        return "âš ï¸ è«‹è¼¸å…¥ä¸€å€‹æ•¸å­—é€²è¡Œé æ¸¬ã€‚", game.get_ui_status()

    guess = int(guess_num)
    
    if guess == game.target:
        msg = f"ğŸ‰ æ­å–œï¼ç­”å°äº†ï¼ç­”æ¡ˆå°±æ˜¯ {game.target}ï¼"
        game.reset(mode, max_stamina)
        return msg, game.get_ui_status()

    # æ‰£è¡€é‚è¼¯ï¼šè‰²å½©åµæŸ¥æˆ°æ‰£ 2ï¼Œå…¶ä»–æ‰£ 1
    penalty = 2 if mode == "è‰²å½©åµæŸ¥æˆ°" else 1
    game.stamina -= penalty
    
    if game.stamina <= 0:
        msg = f"ğŸ’€ é«”åŠ›è€—ç›¡ï¼æ­£ç¢ºç­”æ¡ˆæ˜¯ {game.target}ã€‚è«‹é‡æ–°æŒ‘æˆ°ï¼"
        game.reset(mode, max_stamina)
        return msg, game.get_ui_status()

    # æç¤ºèª
    if guess < game.target:
        game.low = max(game.low, guess + 1)
        feedback = "å¤ªå°äº†!é‚„è¦å†å¤§!"
    else:
        game.high = min(game.high, guess - 1)
        feedback = "å¤ªå¤§äº†!é‚„è¦å†å°!"

    # åœ¨è‰²å½©æ¨¡å¼ä¸‹ç‰¹åˆ¥å¼·åŒ–æ‰£è¡€æç¤º
    penalty_msg = f" (æ³¨æ„ï¼šæ­¤æ¨¡å¼ç­”éŒ¯é‡æ‰£ {penalty} é¡†å¿ƒï¼)" if mode == "è‰²å½©åµæŸ¥æˆ°" else f" (æ‰£é™¤ {penalty} é»é«”åŠ›)"
    return f"{feedback}{penalty_msg}", game.get_ui_status()

# UI ä»‹é¢
with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("# ğŸ”¢ çŒœæ•¸å­—éŠæˆ²ç‰¹åˆ¥ç‰ˆ")
    
    with gr.Row():
        with gr.Column(scale=3):
            display_panel = gr.Textbox(label="æˆ°å ´å³æ™‚æƒ…å ±", lines=15, interactive=False)
            msg_label = gr.Markdown("### ğŸ’¬ å¾…å‘½ç‹€æ…‹ï¼šè«‹è¼¸å…¥é æ¸¬å€¼")
        
        with gr.Column(scale=2):
            mode_selector = gr.Radio(["ç¶“å…¸ç”Ÿå­˜æˆ°", "å±¬æ€§è§£ç¢¼æˆ°", "è‰²å½©åµæŸ¥æˆ°"], label="é¸æ“‡æ¨¡å¼", value="ç¶“å…¸ç”Ÿå­˜æˆ°")
            stamina_selector = gr.Radio([15, 10, 5], label="é›£åº¦ (åˆå§‹é«”åŠ›)", value=10)
            odd_even_ui = gr.Radio(["å¥‡æ•¸", "å¶æ•¸"], label="ğŸ”¹ å¥‡å¶å±¬æ€§é æ¸¬", visible=False)
            input_box = gr.Number(label="ğŸ“ è¼¸å…¥æ•¸å­— (1-100)", precision=0)
            btn_submit = gr.Button("ğŸš€ æäº¤è¡Œå‹•", variant="primary")
            btn_reset = gr.Button("ğŸ”„ é‡ç½®æˆ°å±€")

    mode_selector.change(lambda m: gr.update(visible=(m == "å±¬æ€§è§£ç¢¼æˆ°")), inputs=mode_selector, outputs=odd_even_ui)

    action_inputs = [input_box, mode_selector, stamina_selector, odd_even_ui]
    action_outputs = [msg_label, display_panel]

    btn_submit.click(lambda *args: [f"### çµæœï¼š{res}" for res in play_engine(*args)], inputs=action_inputs, outputs=action_outputs)
    input_box.submit(lambda *args: [f"### çµæœï¼š{res}" for res in play_engine(*args)], inputs=action_inputs, outputs=action_outputs)

    def trigger_reset(m, s):
        status = game.reset(m, s)
        return "### ğŸ’¬ éŠæˆ²å·²é‡ç½®ï¼Œè«‹é–‹å§‹ï¼", status

    btn_reset.click(trigger_reset, inputs=[mode_selector, stamina_selector], outputs=action_outputs)
    mode_selector.change(trigger_reset, inputs=[mode_selector, stamina_selector], outputs=action_outputs)

    demo.load(lambda: game.get_ui_status(), outputs=display_panel)

demo.launch()
